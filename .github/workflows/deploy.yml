name: Deploy

on:
  push:
    branches: [main]
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - staging
          - production

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      version: ${{ steps.set-version.outputs.version }}

    steps:
      - name: Determine environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/tags/v"* ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

      - name: Set version
        id: set-version
        run: |
          if [[ "${{ github.ref }}" == "refs/tags/v"* ]]; then
            echo "version=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
          else
            echo "version=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

  deploy-backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    needs: prepare
    environment:
      name: ${{ needs.prepare.outputs.environment }}
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull Docker image
        run: |
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend:${{ github.sha }}

      - name: Run database migrations
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: |
          docker run --rm \
            -e DATABASE_URL="${{ secrets.DATABASE_URL }}" \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend:${{ github.sha }} \
            npx prisma migrate deploy

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to VPS
        id: deploy
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          ENVIRONMENT: ${{ needs.prepare.outputs.environment }}
        run: |
          echo "üöÄ Deploying to ${{ needs.prepare.outputs.environment }}"
          echo "Version: ${{ needs.prepare.outputs.version }}"
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend:${{ github.sha }}"

          # Deploy via SSH
          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
            set -e
            cd /opt/astralink

            # Pull latest code
            git fetch --all
            git checkout ${{ github.sha }}

            # Create environment file from secrets
            cat > .env << 'ENVEOF'
          ${{ secrets.ENV_FILE }}
          ENVEOF

            # Login to GitHub Container Registry
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Pull latest images
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend:${{ github.sha }}

            # Tag as latest
            docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend:${{ github.sha }} astralink-backend:latest

            # Deploy with zero downtime
            docker-compose --profile production up -d --no-deps --build backend

            # Run migrations
            docker-compose exec -T backend npx prisma migrate deploy

            # Cleanup old images
            docker image prune -f
          EOF

          # Set output URL
          if [ "${{ needs.prepare.outputs.environment }}" == "production" ]; then
            echo "url=https://${{ secrets.DOMAIN }}" >> $GITHUB_OUTPUT
          else
            echo "url=https://staging.${{ secrets.DOMAIN }}" >> $GITHUB_OUTPUT
          fi

      - name: Verify deployment
        env:
          DEPLOY_URL: ${{ steps.deploy.outputs.url }}
        run: |
          echo "Waiting for service to be ready..."
          sleep 10

          # Check health endpoint
          for i in {1..30}; do
            if curl -sf "${DEPLOY_URL}/health" > /dev/null; then
              echo "‚úÖ Deployment verified - service is healthy"
              exit 0
            fi
            echo "Attempt $i/30 - waiting for service..."
            sleep 2
          done

          echo "‚ùå Health check failed"
          exit 1

      - name: Notify deployment
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            Deployment to ${{ needs.prepare.outputs.environment }} ${{ job.status }}
            Version: ${{ needs.prepare.outputs.version }}
            Commit: ${{ github.sha }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
        continue-on-error: true

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [prepare, deploy-backend]
    if: failure() && needs.prepare.outputs.environment == 'production'

    steps:
      - name: Trigger rollback
        run: |
          echo "‚ùå Deployment failed, triggering rollback"
          # TODO: Implement rollback logic
          # - Revert to previous Docker image tag
          # - Rollback database migrations
          # - Notify team

      - name: Notify rollback
        uses: 8398a7/action-slack@v3
        with:
          status: 'failure'
          text: |
            üî¥ Production deployment failed and rollback was triggered
            Commit: ${{ github.sha }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
        continue-on-error: true
